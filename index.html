```html
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Maze Shooter (Three.js)</title>
<style>
  body { margin: 0; overflow: hidden; background: #020617; }
  canvas { display: block; }
</style>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
/* =======================
   BASIC SETUP
======================= */
/**
 * @type {THREE.Scene}
 * @description The scene where all objects will be rendered.
 */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x020617);

/**
 * @type {THREE.OrthographicCamera}
 * @description The camera used to view the scene.  Orthographic camera is used for 2D games.
 */
const camera = new THREE.OrthographicCamera(
  window.innerWidth / -2,
  window.innerWidth / 2,
  window.innerHeight / 2,
  window.innerHeight / -2,
  0.1,
  1000
);
camera.position.z = 10;

/**
 * @type {THREE.WebGLRenderer}
 * @description The renderer responsible for drawing the scene.
 */
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

/* =======================
   MAZE
======================= */
/**
 * @constant {number} TILE - The size of each tile in the maze.
 */
const TILE = 80;
/**
 * @constant {string[]} maze - A 2D array representing the maze layout.  '#' represents walls, '.' represents open spaces.
 */
const maze = [
  "##########",
  "#........#",
  "#.####...#",
  "#....#...#",
  "###..#.###.",
  "#....#...#",
  "#.######.#",
  "#........#",
  "##########"
];

/**
 * @type {THREE.Mesh[]} walls - An array to store the wall meshes.
 */
const walls = [];
/**
 * @type {THREE.MeshBasicMaterial} wallMat - The material used for the walls.
 */
const wallMat = new THREE.MeshBasicMaterial({ color: 0x334155 });

maze.forEach((row, y) => {
  [...row].forEach((cell, x) => {
    if (cell === "#") {
      const wall = new THREE.Mesh(
        new THREE.BoxGeometry(TILE, TILE, 1),
        wallMat
      );
      wall.position.set(
        x * TILE - (maze[0].length * TILE) / 2,
        -y * TILE + (maze.length * TILE) / 2,
        0
      );
      scene.add(wall);
      walls.push(wall);
    }
  });
});

/* =======================
   PLAYER
======================= */
/**
 * @type {THREE.Mesh} player - The player's character.
 */
const player = new THREE.Mesh(
  new THREE.CircleGeometry(25, 24),
  new THREE.MeshBasicMaterial({ color: 0x22d3ee })
);
player.position.set(-300, 300, 0);
scene.add(player);

/**
 * @type {object} keys - An object to track which keys are pressed.
 */
const keys = {};
addEventListener("keydown", e => keys[e.key] = true);
addEventListener("keyup", e => keys[e.key] = false);

/* =======================
   BULLETS
======================= */
/**
 * @type {THREE.Mesh[]} bullets - An array to store the bullet meshes.
 */
const bullets = [];

addEventListener("click", e => {
  const bullet = new THREE.Mesh(
    new THREE.CircleGeometry(6, 12),
    new THREE.MeshBasicMaterial({ color: 0xf87171 })
  );
  bullet.position.copy(player.position);

  const dir = new THREE.Vector2(
    e.clientX - window.innerWidth / 2,
    -(e.clientY - window.innerHeight / 2)
  ).normalize();

  bullet.velocity = dir.multiplyScalar(14);
  bullets.push(bullet);
  scene.add(bullet);
});

/* =======================
   ENEMIES
======================= */
/**
 * @type {THREE.Mesh[]} enemies - An array to store the enemy meshes.
 */
const enemies = [];

/**
 * @function spawnEnemy
 * @param {number} x - The x-coordinate to spawn the enemy.
 * @param {number} y - The y-coordinate to spawn the enemy.
 * @description Spawns a new enemy at the specified coordinates.
 */
function spawnEnemy(x, y) {
  const enemy = new THREE.Mesh(
    new THREE.BoxGeometry(40, 40, 1),
    new THREE.MeshBasicMaterial({ color: 0xef4444 })
  );
  enemy.position.set(x, y, 0);
  enemy.hp = 3;
  enemies.push(enemy);
  scene.add(enemy);
}

/* =======================
   CONTINUOUS SPAWNER (FIX)
======================= */
/**
 * @type {number} spawnTimer - A timer to control enemy spawning.
 */
let spawnTimer = 0;
/**
 * @constant {number} MAX_ENEMIES - The maximum number of enemies allowed on the screen.
 */
const MAX_ENEMIES = 6;

/* =======================
   COLLISION
======================= */
/**
 * @function collides
 * @param {THREE.Mesh} a - The first object.
 * @param {THREE.Mesh} b - The second object.
 * @param {number} [sizeA=30] - The size of the first object.
 * @param {number} [sizeB=40] - The size of the second object.
 * @returns {boolean} - True if the objects collide, false otherwise.
 * @description Checks if two objects are colliding.
 */
function collides(a, b, sizeA = 30, sizeB = 40) {
  return (
    Math.abs(a.position.x - b.position.x) < sizeA + sizeB &&
    Math.abs(a.position.y - b.position.y) < sizeA + sizeB
  );
}

/* =======================
   GAME LOOP
======================= */
/**
 * @function animate
 * @description The main animation loop.
 */
function animate() {
  requestAnimationFrame(animate);

  /* PLAYER MOVE */
  const speed = 6;
  if (keys["ArrowUp"] || keys["w"]) player.position.y += speed;
  if (keys["ArrowDown"] || keys["s"]) player.position.y -= speed;
  if (keys["ArrowLeft"] || keys["a"]) player.position.x -= speed;
  if (keys["ArrowRight"] || keys["d"]) player.position.x += speed;

  /* BULLETS */
  bullets.forEach((b, i) => {
    b.position.x += b.velocity.x;
    b.position.y += b.velocity.y;

    enemies.forEach((e, ei) => {
      if (collides(b, e)) {
        e.hp--;
        scene.remove(b);
        bullets.splice(i, 1);

        if (e.hp <= 0) {
          scene.remove(e);
          enemies.splice(ei, 1);
        }
      }
    });
  });

  /* ENEMIES MOVE */
  enemies.forEach(e => {
    const dir = new THREE.Vector2(
      player.position.x - e.position.x,
      player.position.y - e.position.y
    ).normalize();

    e.position.x += dir.x * 2;
    e.position.y += dir.y * 2;
  });

  /* ENEMY SPAWNING (FIXED) */
  spawnTimer++;
  if (spawnTimer > 120 && enemies.length < MAX_ENEMIES) {
    spawnTimer = 0;

    let x, y;
    while (true) {
      const tx = Math.floor(Math.random() * maze[0].length);
      const ty = Math.floor(Math.random() * maze.length);

      if (maze[ty][tx] === ".") {
        x = tx * TILE - (maze[0].length * TILE) / 2;
        y = -ty * TILE + (maze.length * TILE) / 2;
        break;
      }
    }

    spawnEnemy(x, y);
  }

  renderer.render(scene, camera);
}

animate();

/* =======================
   RESIZE
======================= */
/**
 * @function resize
 * @description Handles the window resize event.
 */
addEventListener("resize", () => {
  camera.left = window.innerWidth / -2;
  camera.right = window.innerWidth / 2;
  camera.top = window.innerHeight / 2;
  camera.bottom = window.innerHeight / -2;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
```
