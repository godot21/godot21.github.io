<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Maze Shooter (Three.js)</title>
<style>
  body { margin: 0; overflow: hidden; background: #020617; }
  canvas { display: block; }
</style>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
/* =======================
   BASIC SETUP
======================= */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x020617);

const camera = new THREE.OrthographicCamera(
  window.innerWidth / -2,
  window.innerWidth / 2,
  window.innerHeight / 2,
  window.innerHeight / -2,
  0.1,
  1000
);
camera.position.z = 10;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

/* =======================
   MAZE
======================= */
const TILE = 80;
const maze = [
  "##########",
  "#........#",
  "#.####...#",
  "#....#...#",
  "###..#.###.",
  "#....#...#",
  "#.######.#",
  "#........#",
  "##########"
];

const walls = [];
const wallMat = new THREE.MeshBasicMaterial({ color: 0x334155 });

maze.forEach((row, y) => {
  [...row].forEach((cell, x) => {
    if (cell === "#") {
      const wall = new THREE.Mesh(
        new THREE.BoxGeometry(TILE, TILE, 1),
        wallMat
      );
      wall.position.set(
        x * TILE - (maze[0].length * TILE) / 2,
        -y * TILE + (maze.length * TILE) / 2,
        0
      );
      scene.add(wall);
      walls.push(wall);
    }
  });
});

/* =======================
   PLAYER
======================= */
const player = new THREE.Mesh(
  new THREE.CircleGeometry(25, 24),
  new THREE.MeshBasicMaterial({ color: 0x22d3ee })
);
player.position.set(-300, 300, 0);
scene.add(player);

const keys = {};
addEventListener("keydown", e => keys[e.key] = true);
addEventListener("keyup", e => keys[e.key] = false);

/* =======================
   BULLETS
======================= */
const bullets = [];

addEventListener("click", e => {
  const bullet = new THREE.Mesh(
    new THREE.CircleGeometry(6, 12),
    new THREE.MeshBasicMaterial({ color: 0xf87171 })
  );
  bullet.position.copy(player.position);

  const dir = new THREE.Vector2(
    e.clientX - window.innerWidth / 2,
    -(e.clientY - window.innerHeight / 2)
  ).normalize();

  bullet.velocity = dir.multiplyScalar(14);
  bullets.push(bullet);
  scene.add(bullet);
});

/* =======================
   ENEMIES
======================= */
const enemies = [];

function spawnEnemy(x, y) {
  const enemy = new THREE.Mesh(
    new THREE.BoxGeometry(40, 40, 1),
    new THREE.MeshBasicMaterial({ color: 0xef4444 })
  );
  enemy.position.set(x, y, 0);
  enemy.hp = 3;
  enemies.push(enemy);
  scene.add(enemy);
}

/* =======================
   CONTINUOUS SPAWNER (FIX)
======================= */
let spawnTimer = 0;
const MAX_ENEMIES = 6;

/* =======================
   COLLISION
======================= */
function collides(a, b, sizeA = 30, sizeB = 40) {
  return (
    Math.abs(a.position.x - b.position.x) < sizeA + sizeB &&
    Math.abs(a.position.y - b.position.y) < sizeA + sizeB
  );
}

/* =======================
   GAME LOOP
======================= */
function animate() {
  requestAnimationFrame(animate);

  /* PLAYER MOVE */
  const speed = 6;
  if (keys["ArrowUp"] || keys["w"]) player.position.y += speed;
  if (keys["ArrowDown"] || keys["s"]) player.position.y -= speed;
  if (keys["ArrowLeft"] || keys["a"]) player.position.x -= speed;
  if (keys["ArrowRight"] || keys["d"]) player.position.x += speed;

  /* BULLETS */
  bullets.forEach((b, i) => {
    b.position.x += b.velocity.x;
    b.position.y += b.velocity.y;

    enemies.forEach((e, ei) => {
      if (collides(b, e)) {
        e.hp--;
        scene.remove(b);
        bullets.splice(i, 1);

        if (e.hp <= 0) {
          scene.remove(e);
          enemies.splice(ei, 1);
        }
      }
    });
  });

  /* ENEMIES MOVE */
  enemies.forEach(e => {
    const dir = new THREE.Vector2(
      player.position.x - e.position.x,
      player.position.y - e.position.y
    ).normalize();

    e.position.x += dir.x * 2;
    e.position.y += dir.y * 2;
  });

  /* ENEMY SPAWNING (FIXED) */
  spawnTimer++;
  if (spawnTimer > 120 && enemies.length < MAX_ENEMIES) {
    spawnTimer = 0;

    let x, y;
    while (true) {
      const tx = Math.floor(Math.random() * maze[0].length);
      const ty = Math.floor(Math.random() * maze.length);

      if (maze[ty][tx] === ".") {
        x = tx * TILE - (maze[0].length * TILE) / 2;
        y = -ty * TILE + (maze.length * TILE) / 2;
        break;
      }
    }

    spawnEnemy(x, y);
  }

  renderer.render(scene, camera);
}

animate();

/* =======================
   RESIZE
======================= */
addEventListener("resize", () => {
  camera.left = window.innerWidth / -2;
  camera.right = window.innerWidth / 2;
  camera.top = window.innerHeight / 2;
  camera.bottom = window.innerHeight / -2;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
